import { readCsv } from './read-csv'
import { writeFileSync, readFileSync, readdirSync, statSync } from 'fs'
import { join } from 'path'
import { format, resolveConfig, Options } from 'prettier'

const urls = {
  cnOpcodes: 'https://raw.githubusercontent.com/zhyupe/ffxiv-opcode-worker/refs/heads/master/cn-opcodes.csv',
}

const codePath = join(__dirname, '..')
const cacheDir = join(codePath, 'sync')
const ipcRoot = join(codePath, 'definitions/ipc')

let prettierOptions: Options | null = null
async function writeCode(path: string, content: string) {
  if (prettierOptions === null) {
    prettierOptions = (await resolveConfig(__dirname)) || {}
    prettierOptions.parser = 'babel-ts'
  }

  const contentWithBanner = '// Generated by src/sync/index.ts\n\n' + content

  writeFileSync(join(codePath, path), contentWithBanner)
  writeFileSync(
    join(codePath, path),
    await format(contentWithBanner, prettierOptions),
  )
}

async function request(url: string, cacheFile: string, cacheTime = 3600e3) {
  try {
    const stat = statSync(cacheFile)
    if (Date.now() - stat.mtimeMs < cacheTime) {
      return readFileSync(cacheFile, 'utf-8')
    }
  } catch (e) {
    //
  }

  const res = await fetch(url)
  const body = await res.text()

  writeFileSync(cacheFile, body)
  return body
}

const commentRegex = /\/\*\s*ipc:([\w, ])+\s*\*\//g
const exportRegex = /export (?:class|const) (\w+)/g
const fileFilter = (file: string) =>
  !file.startsWith('.') && file.endsWith('.ts')

function readIPCs() {
  const files = readdirSync(ipcRoot).filter(
    (file) => fileFilter(file) && file !== 'index.ts',
  )
  files.sort()

  const map: Array<{ file: string; exports: string[] }> = []
  for (const file of files) {
    const content = readFileSync(join(ipcRoot, file), 'utf-8')
    const exports = []

    let match: RegExpExecArray | null
    while ((match = commentRegex.exec(content))) {
      exports.push(...match[1].split(',').map((item) => item.trim()))
    }

    if (!exports.length) {
      while ((match = exportRegex.exec(content))) {
        exports.push(match[1])
      }
    }

    map.push({ file: file.substr(0, file.length - 3), exports })
  }

  console.log(map)
  return map
}

function generateOpcodeFile(
  region: string,
  version: string,
  table: Array<Record<string, string>>,
  opcodeTypes: string[],
) {
  const opcodes: Record<
    string,
    Array<{ type: string; size?: number; outgoing?: boolean }>
  > = {}
  for (const {
    Name: name,
    Len: size,
    Scope: scope,
    [version]: _opcode = '',
  } of table) {
    if (!name || !_opcode) {
      console.log(`Invalid row: ${version}, ${name}, ${_opcode}`)
      continue
    }

    if (!opcodeTypes.includes(name)) {
      continue
    }

    const opcode = _opcode.toLowerCase()
    if (!opcodes[opcode]) {
      opcodes[opcode] = []
    }

    let outgoing = undefined
    if (scope === 'ServerZoneIpc') {
      outgoing = false
    } else if (scope === 'ClientZoneIpc') {
      outgoing = true
    }

    opcodes[opcode].push({
      type: name,
      size: size ? +size : undefined,
      outgoing,
    })
  }

  return `
import { OpcodeMap } from './opcode-map.type'
import { NormalizedOpcode } from './normalized-opcode.enum'

export const ${region}_${version.replace(/\./g, '_')}: OpcodeMap = {
${Object.entries(opcodes)
  .sort(([a], [b]) => parseInt(a, 16) - parseInt(b, 16))
  .map(
    ([opcode, items]) => `  ${opcode}: [
${items
  .map(
    (item) =>
      `    { type: NormalizedOpcode.${item.type}${
        typeof item.outgoing === 'boolean'
          ? `, outgoing: ${item.outgoing ? 'true' : 'false'}`
          : ''
      }${typeof item.size === 'number' ? `, size: ${item.size}` : ''} },`,
  )
  .join('\n')}
  ],`,
  )
  .join('\n')}
}
`
}

function generateIndexFile() {
  const outputs = readdirSync(join(codePath, 'opcode'));
  const versions: Record<string, string[]> = {
    CN: outputs
    .map((item) => /cn-(.+)\.ts/.exec(item)?.[1])
    .filter((item) => item) as string[],
    Global: outputs
      .map((item) => /global-(.+)\.ts/.exec(item)?.[1])
      .filter((item) => item) as string[],
  }
  return `
export * from './normalized-opcode.enum'
export * from './opcode-map.type'

${Object.entries(versions)
  .map(([k, vs]) =>
    vs
      .map(
        (v) =>
          `import { ${k}_${v.replace(
            /\./g,
            '_',
          )} } from './${k.toLowerCase()}-${v}'`,
      )
      .join('\n'),
  )
  .join('\n')}
${Object.entries(versions)
  .map(
    ([k, vs]) => `
export const ${k}Opcode = {
${vs.map((v) => `  '${v}': ${k}_${v.replace(/\./g, '_')},`).join('\n')}
}`,
  )
  .join('\n')}
`
}

function generateNormalizedOpcodeFile(opcodes: string[]) {
  return `
export enum NormalizedOpcode {
${opcodes.map((item) => `  ${item} = '${item}',`).join('\n')}
}
`
}

function generateIPCIndexFile(
  ipcs: ReturnType<typeof readIPCs>,
  exports: string[],
  commonFiles: string[],
) {
  return `
import { NormalizedOpcode } from '../opcode'
import { StructConstructor } from '@/struct/struct'
${ipcs
  .map((item) => `import { ${item.exports.join(', ')} } from './${item.file}'`)
  .join('\n')}

function packetMapTypeConstraint<T extends Partial<Record<NormalizedOpcode, StructConstructor>>>(map: T) {
  return map as { [K in NormalizedOpcode]: T extends { [k in K]: infer R } ? R : undefined }
}

export const PacketMap = packetMapTypeConstraint({
${exports.map((item) => `  [NormalizedOpcode.${item}]: ${item},`).join('\n')}
})

export {
${exports.map((item) => `  ${item},`).join('\n')}
}

${commonFiles.map((item) => `export * from './common/${item}'`).join('\n')}
`
}

function tcToTable(text: string, region: string, version: string): any[] {
  return Object.values(
    JSON.parse(text).reduce((out: any, item: any) => {
      if (item.region !== region) {
        return out
      }

      Object.entries(item.lists).forEach(([scope, rows]: any) => {
        for (const { name, opcode } of rows) {
          if (!out[name]) {
            out[name] = {
              Name: name,
              Len: 0,
              Scope: scope,
            }
          }

          out[name][version] = `0x${opcode.toString(16).padStart(4, '0')}`
        }
      })
      return out
    }, {}),
  )
}

async function main() {
  const ipcs = readIPCs()
  const exports = ([] as string[]).concat(...ipcs.map((item) => item.exports))
  exports.sort()

  await writeCode(
    `opcode/normalized-opcode.enum.ts`,
    generateNormalizedOpcodeFile(exports),
  )

  const commonFiles = readdirSync(join(ipcRoot, 'common'))
    .filter(fileFilter)
    .map((item) => item.substr(0, item.length - 3))
  await writeCode(
    `definitions/ipc/index.ts`,
    generateIPCIndexFile(ipcs, exports, commonFiles),
  )

  const cnOpcodes = await request(
    urls.cnOpcodes,
    join(cacheDir, 'cn-opcodes.cache'),
  )
  const table = readCsv(cnOpcodes, null, { header: 0, skip: 1 })
  const cnVersions = Object.keys(table[0]).filter(a => /\d\.\d+/.test(a))
  for (const version of cnVersions) {
    await writeCode(
      `opcode/cn-${version}.ts`,
      generateOpcodeFile('CN', version, table, exports),
    )
  }

  await writeCode(`opcode/index.ts`, generateIndexFile())
}

void main()
